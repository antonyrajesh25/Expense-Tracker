<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Expense Tracker</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom styles for aesthetic enhancements */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .mic-button {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            will-change: transform;
            /* Aesthetic circle button */
            width: 80px;
            height: 80px;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.5), 0 4px 6px -2px rgba(59, 130, 246, 0.05);
        }
        .mic-button.listening {
            animation: pulse-red 1.5s infinite;
            background-color: #ef4444; /* Red for recording */
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .container-card {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 0 10px -5px rgba(0, 0, 0, 0.04);
            max-width: 600px;
            margin: 20px auto;
            border-radius: 1rem;
        }
        .transaction-item:not(:last-child) {
            border-bottom: 1px solid #e5e7eb;
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="container-card bg-white p-6 md:p-8">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-extrabold text-blue-600 flex items-center justify-center">
                <i data-lucide="mic" class="w-6 h-6 mr-2"></i>
                Voice Expense Tracker
            </h1>
            <p class="text-gray-500 mt-1">Log expenses instantly using your voice.</p>
        </header>

        <!-- Totals Display -->
        <div class="mb-8 p-4 bg-gray-50 rounded-lg shadow-inner">
            <h2 class="text-lg font-semibold text-gray-700">Total Expenses</h2>
            <p id="total-expenses" class="text-4xl font-bold text-red-600 mt-1">$0.00</p>
        </div>

        <!-- Voice Input Section -->
        <div class="text-center mb-8">
            <button id="mic-button" class="mic-button bg-blue-500 text-white rounded-full flex items-center justify-center mx-auto shadow-lg hover:bg-blue-600 active:scale-95 transition-all">
                <i data-lucide="mic" class="w-8 h-8"></i>
            </button>
            <p id="status-message" class="mt-4 text-sm font-medium text-gray-600 min-h-[1.25rem]">Click to start speaking.</p>
        </div>

        <!-- Recent Transactions -->
        <section>
            <h2 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Recent Transactions</h2>
            <div id="transactions-list" class="space-y-3 max-h-80 overflow-y-auto">
                <!-- Transactions will be inserted here -->
                <p class="text-gray-500 text-center py-4" id="loading-message">Loading expenses...</p>
            </div>
        </section>

        <!-- User ID for Multi-User context -->
        <div class="mt-8 pt-4 border-t text-sm text-gray-400 text-center">
            User ID: <span id="user-id">Loading...</span>
        </div>
        
    </div>

    <!-- Firebase and core logic scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, addDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- ðŸš¨ CRITICAL FIX: FIREBASE CONFIGURATION ðŸš¨ ---
        // When running outside the Gemini/Canvas environment (like on GitHub Pages), 
        // the app cannot access the __firebase_config variable.
        // You MUST replace the placeholder below with your actual Firebase config object 
        // from your project's console. If you don't do this, the app will fail to initialize.
        
        const REAL_FIREBASE_CONFIG = {
            apiKey: "YOUR_API_KEY", // <--- REPLACE THIS WITH YOUR REAL API KEY
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };
        
        // We initialize using the canvas config if available, otherwise we use the placeholder
        const firebaseConfig = (typeof __firebase_config !== 'undefined' && JSON.parse(__firebase_config).projectId) 
            ? JSON.parse(__firebase_config) 
            : REAL_FIREBASE_CONFIG;
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId || 'default-app-id';

        let db, auth;
        let currentUserId = null;
        let recognition = null; // Will hold SpeechRecognition object

        const statusMessage = document.getElementById('status-message');
        const micButton = document.getElementById('mic-button');
        const transactionsList = document.getElementById('transactions-list');
        const totalExpensesElement = document.getElementById('total-expenses');
        const userIdElement = document.getElementById('user-id');
        const loadingMessage = document.getElementById('loading-message');

        // Helper to format currency
        const formatter = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
        });
        
        // Utility for exponential backoff during API calls
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    if (response.status === 429) { // Too Many Requests
                        throw new Error('Rate limit exceeded');
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) throw error;
                    
                    // Exponential backoff wait time
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        

        // --- FIREBASE INITIALIZATION ---

        function setupFirebase() {
            if (!firebaseConfig.projectId || firebaseConfig.projectId === 'YOUR_PROJECT_ID') {
                statusMessage.textContent = "FATAL: Firebase is not configured. Check the code for instructions.";
                micButton.disabled = true;
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('error'); // Keep console clean unless error occurs
                
                // 1. Initial Authentication (uses the token from Canvas if available)
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        userIdElement.textContent = currentUserId;
                        statusMessage.textContent = "Ready! Click to start speaking.";
                        micButton.disabled = false;
                        loadExpenses();
                    } else {
                        // Sign in anonymously if no user is found (standard for public apps)
                        if (typeof __initial_auth_token !== 'undefined') {
                            // Use Canvas token if available
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            // Fallback for public deployment outside Canvas
                            await signInAnonymously(auth);
                        }
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization Failed:", error);
                statusMessage.textContent = "Failed to initialize Firebase. Check console for details.";
                micButton.disabled = true;
            }
        }

        // --- EXPENSE HANDLING ---

        function loadExpenses() {
            if (!db || !currentUserId) return;

            const collectionPath = `/artifacts/${appId}/users/${currentUserId}/expenses`;
            const q = query(collection(db, collectionPath));

            onSnapshot(q, (snapshot) => {
                const expenses = [];
                let total = 0;
                
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const amount = parseFloat(data.amount) || 0;
                    expenses.push({ 
                        id: doc.id, 
                        ...data, 
                        amount: amount 
                    });
                    total += amount;
                });
                
                // Sort by timestamp (newest first)
                expenses.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

                renderExpenses(expenses);
                totalExpensesElement.textContent = formatter.format(total);
            }, (error) => {
                console.error("Error listening to expenses:", error);
                loadingMessage.textContent = "Error loading expenses.";
            });
        }
        
        function renderExpenses(expenses) {
            transactionsList.innerHTML = '';
            loadingMessage.style.display = 'none';

            if (expenses.length === 0) {
                transactionsList.innerHTML = '<p class="text-gray-500 text-center py-4">No transactions logged yet.</p>';
                return;
            }

            expenses.forEach(expense => {
                const date = expense.timestamp ? expense.timestamp.toDate().toLocaleDateString() : 'N/A';
                const time = expense.timestamp ? expense.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                
                const item = document.createElement('div');
                item.className = 'transaction-item flex justify-between items-center p-3 hover:bg-gray-100 rounded-lg';
                item.innerHTML = `
                    <div class="flex-1 min-w-0">
                        <p class="font-semibold text-gray-800">${expense.description || expense.category || 'Expense'}</p>
                        <p class="text-xs text-gray-500 truncate">${expense.category ? 'Category: ' + expense.category : ''}</p>
                        <p class="text-xs text-gray-400">${date} ${time}</p>
                    </div>
                    <div class="text-right">
                        <p class="text-lg font-bold text-red-600">${formatter.format(expense.amount)}</p>
                    </div>
                `;
                transactionsList.appendChild(item);
            });
        }


        // --- GEMINI API CALLS ---

        async function parseExpenseWithGemini(transcription) {
            const systemPrompt = "You are an expert expense parser. Analyze the user's transcription and extract the amount, category, and a short description. The amount MUST be a numerical value (USD) without currency symbols. Categories should be simple (e.g., 'Groceries', 'Rent', 'Gas'). Only respond with a JSON object. If no amount is found, use 0.";
            const userQuery = `Parse this expense: "${transcription}"`;
            const apiKey = "" 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            amount: { type: "NUMBER", description: "The numerical amount of the expense, e.g., 35.50" },
                            category: { type: "STRING", description: "The general category, e.g., Groceries, Transport" },
                            description: { type: "STRING", description: "A brief description of the expense." }
                        },
                        propertyOrdering: ["amount", "category", "description"]
                    }
                }
            };

            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0 && result.candidates[0].content) {
                const jsonText = result.candidates[0].content.parts[0].text;
                try {
                    return JSON.parse(jsonText);
                } catch (e) {
                    console.error("Failed to parse AI JSON response:", jsonText, e);
                    return null;
                }
            }
            return null;
        }

        async function saveExpenseToFirestore(expenseData) {
            if (!db || !currentUserId) {
                statusMessage.textContent = "Error: Database not ready.";
                return;
            }

            const amount = parseFloat(expenseData.amount) || 0;
            if (amount <= 0) {
                statusMessage.textContent = "Error: Amount must be greater than zero.";
                return;
            }

            const expenseRecord = {
                amount: amount,
                category: expenseData.category || 'Uncategorized',
                description: expenseData.description || 'Logged via voice',
                timestamp: serverTimestamp(),
                userId: currentUserId 
            };
            
            try {
                const collectionPath = `/artifacts/${appId}/users/${currentUserId}/expenses`;
                await addDoc(collection(db, collectionPath), expenseRecord);
                statusMessage.textContent = "Expense saved successfully!";
            } catch (error) {
                console.error("Error saving expense:", error);
                statusMessage.textContent = "Error saving expense to database.";
            }
        }

        // --- VOICE RECOGNITION ---

        function setupSpeechRecognition() {
            // Check for Speech Recognition API support
            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (!window.SpeechRecognition) {
                statusMessage.textContent = "Voice recognition not supported in this browser.";
                micButton.disabled = true;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                micButton.classList.add('listening');
                micButton.innerHTML = `<i data-lucide="mic" class="w-8 h-8 text-white"></i>`;
                lucide.createIcons(); // Re-render icon
                statusMessage.textContent = "Listening...";
            };

            recognition.onresult = async (event) => {
                const transcription = event.results[0][0].transcript;
                statusMessage.textContent = `Heard: "${transcription}"`;

                micButton.classList.remove('listening');
                micButton.innerHTML = `<i data-lucide="loader" class="w-8 h-8 animate-spin"></i>`;
                lucide.createIcons();
                statusMessage.textContent = "Analyzing transcription with AI...";

                const expenseData = await parseExpenseWithGemini(transcription);

                if (expenseData && expenseData.amount > 0) {
                    await saveExpenseToFirestore(expenseData);
                } else {
                    statusMessage.textContent = "Could not parse valid expense (amount > 0). Try again.";
                    micButton.innerHTML = `<i data-lucide="mic" class="w-8 h-8"></i>`;
                    lucide.createIcons();
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                micButton.classList.remove('listening');
                micButton.innerHTML = `<i data-lucide="mic" class="w-8 h-8"></i>`;
                lucide.createIcons();
                statusMessage.textContent = `Error: ${event.error}. Try again.`;
            };

            recognition.onend = () => {
                micButton.classList.remove('listening');
                micButton.innerHTML = `<i data-lucide="mic" class="w-8 h-8"></i>`;
                lucide.createIcons();
                if (statusMessage.textContent.startsWith("Heard:") || statusMessage.textContent === "Listening...") {
                     // Only revert if no save operation is pending
                    statusMessage.textContent = "Click to start speaking.";
                }
            };
            
            micButton.onclick = () => {
                if (!micButton.classList.contains('listening')) {
                    recognition.start();
                } else {
                    recognition.stop();
                }
            };
        }


        // --- INITIAL SETUP ---

        window.onload = () => {
            // Initialize Firebase and Auth
            setupFirebase();

            // Set up Voice Recognition
            setupSpeechRecognition();

            // Render Lucide icons
            lucide.createIcons();
        };

    </script>
</body>
</html>

